\documentclass{article}
    % General document formatting
    \usepackage[margin=0.5in]{geometry}
    \usepackage[parfill]{parskip}
    \usepackage[utf8]{inputenc}
    \usepackage[T2A]{fontenc}
    \usepackage[english,russian]{babel}
    
    % Related to math
    \usepackage{amsmath,amssymb,amsfonts,amsthm}

    \usepackage{tikz}
    \usetikzlibrary{patterns}
    \usepackage{graphicx}
    
\begin{document}

\section{Введение}

\section{Постановка задачи}

Пусть на эвклидовой плоскости
$\mathbb R$ задано $n$ плоских деталей
$A_1, A_2, \dots A_n$,
ограниченных $k$ замкнутыми попарно не пересекающимися контурами
$C_1, C_2, \dots C_k$,
таким образом
$$
\bigcup_{i=1}^n \delta A_i = \bigcup_{j=1}^k C_k
$$
Сами замкнутые контуры состоят из конечного числа
отрезков прямых линий и дуг окружностей.

Для упрощения задачи мы будем считать,
что резка ведётся не по эквидистантному контуру,
а непосредственно по контуру детали:
сегмент резки
$S_i = C_i, \forall i=\overline{1, k}$
и точка врезки $M_i$ всегда совпадает с точкой выключения
инструмента и тоже лежит непосредственно
на контуре:
$M_i \equiv M_i^* \in C_i, \forall i = \overline{1, k}$.

Также будем считать заданной точку начала маршрута резки $M_0$.

В этих обозначениях задача CCP
(Continous Cutting Problem)
заключается в нахождении
\begin{enumerate}
    \item{$k$ точек врезки $M_i \in C_i$}
    \item{Порядка обхода контуров $C_i$,
    то есть перестановки $k$ элементов
    $I=(i_1, i_2, \dots, i_k),
    i_j \in \overline{1,k}, \forall j \in \overline{1,k}$}
\end{enumerate}

В качестве целевой функции берём время резки,
в общем виде:
$$
T = \frac{1}{V_{on}} \sum_{j=1}^k |C_{i_j}| +
\frac{1}{V_{off}} \sum_{j=0}^k |\overrightarrow{M_{i_j} M_{i_{{j+1}}}}|
$$
где $V_{on}$ и $V_{off}$ --
скорость резки и холостого хода соответственно. 
Также будем считать для краткости,
что
$M_{i_0} = M_{i_{k+1}} = M_0$.

В данном случае можно упростить целевую функцию
до длины холостого хода:
$$
\mathcal L = \sum_{j=0}^k |\overrightarrow{M_{i_j} M_{i_{{j+1}}}}|
$$
$$
\mathcal L \to \min
$$

При решении данной задачи мы будем дополнительно
соблюдать
\textit{ограничение предшествования},
которое традиционно формулируется в виде двух правил:
\begin{enumerate}
\item{}
Если деталь ограничена внешним контуром и одним
или несколькими внутренними контурами
(содержит отверстия),
то внутренние контуры должны
быть вырезаны до того,
как будет завершена резка внешнего контура
\item{}
Если деталь расположена в отверстии
другой детали
(внутри её внутреннего контура),
то внутренняя деталь
должна быть вырезана до того,
как будет завершена резка
содержащего её контура
(другой детали)
\end{enumerate}

В данном случае эти условия упрощаются до одного:
если некоторый контур расположен внутри другого,
то он должен быть вырезан раньше его:
$$
\tilde C_a \subset \tilde C_b
\Rightarrow
i_a < i_b
$$
где под
$\tilde C_i$ понимается фигура,
ограниченная контуром $C_i$.

В такой формулировке ограничение предшествования
ограничивает множество возможных перестановок
$I=(i_1, i_2, \dots, i_k)$,
входящих в полное решение задачи
$\big<
i_1, i_2, \dots i_k,
M_1, M_2, \dots M_k
\big>$.

Традиционным способом решения сформулированной задачи CCP
является сведение её к обобщённой задаче коммивояжера
(Generalized Traveling Salesman Problem, GTSP)
путём дискретизации контуров
$C_i, i=\overline{1, k}$
с некоторым шагом $\varepsilon$
и последующим выбором точек врезки
$M_i$ из конечного множества кандидатов.

В данной статье мы вместо этого решаем задачу непрерывной оптимизации
для поиска точек врезки $M_i$.

\section{Непрерывная оптимизация}
В практических приложениях
форма контуров деталей ограничена
набором отрезков прямых линий и дуг окружностей.
В этих условиях оказывается возможным
точно решить задачу нахождения
\textit{одной} точки врезки
при фиксированном положении всех остальных $M_i$,
а также порядка обхода $I=(i_1, i_2, \dots, i_k)$.
$$
\mathcal L \to \min_{M_i}
$$
что упрощается до
$$
\sqrt{\overrightarrow{M_i M_{i-1}}^2} +
\sqrt{\overrightarrow{M_i M_{i+1}}^2} \to
\min_{M_i \in C_i}
$$
Простейший геометрический анализ показывает,
что если соседние
(считающиеся известными)
точки врезки расположены
\textit{с одной стороны}
сегмента контура
(точнее, содержащей его линии или окружности),
то точное решение оптимизационной задачи
находится как пересечение
соединяющей линии $M_{i-1}M_{i+1}$
с прямой или окружностью,
на которой лежит сегмент.

Если же обе точки находятся
\textit{с одной стороны},
то решение находится при помощи принципа Ферма,
так чтобы соблюдалось правило
\textit{угол падения равен углу отражения},
как это можно видеть на рис. \ref{fermat}.

По аналогии с ALS
(Alternating Least Squares)
оказывается возможным использовать
процесс,
который можно было бы назвать
\textit{Alternative Fermat Principle}:
\begin{itemize}
    \item{}
    Начальные положения точек врезки 
    $M_i \in C_i$
    выбираются
    (для каждого контура)
    случайным образом
    \item{}
    $\forall i \in \overline{1,k}$
    решается задача поиска оптимального положения
    \textit{одной} точки врезки $M_i$
    (за константное время $O(1)$)
    \item{}
    Процесс повторяется до схождения
    по позициям всех точек врезки
    (с некоторой наперёд заданной точностью)
\end{itemize}
С практической точки зрения процесс оказывается
очень хорошо сходящимся за время $O(k)$.
Поэтому он используется в качестве одного шага
полного алгоритма непрерывно-дискретной оптимизации.

\begin{figure}
    \begin{center}
    \tikz[rotate=27,scale=1.1]{
        \draw[thick]
            (0, 0) coordinate(zero) -- (5, 0) coordinate(future) node[right] {$S_k$};
        \fill[black] 
            (1.5, 0) circle(0.1) coordinate(middle) node[below right]  {$M_i \equiv M_i^*$}
            (1, 1) circle(0.1) coordinate(from) node[above left] {$M_{i-1}$} ++(-1.5,0) node[above] {$S_{k-1}$}
            (4.5, 2) circle(0.1) coordinate(to) node[above] {$M_{i+1}$} ++(1.5,0) node[below] {$S_{i+1}$};
        \begin{scope}
            \clip (from) circle(1);
            \draw[thick] (from) ++(0, 3) circle(3);
        \end{scope};
        \begin{scope}
            \clip (to) circle(1.5);
            \draw[thick] (to) ++(3, 4) circle(5);
        \end{scope};
        \draw[dashed] (from) -- (middle) -- (to);
        \draw[thin] (4.5, -2) circle(0.062) coordinate(mirror) node[right] {$\hat M_{i+1}$};
        \coordinate (opt) at (intersection of zero--future and mirror--from);
        \draw[thin] (opt) circle(0.1);
        \draw[dotted] 
            (mirror) -- (opt)
            (mirror) -- (to);
        \draw[thin] (from) -- (opt) -- (to);

        \draw[->,>=latex,red,thick] (middle) to[bend right] (opt);
        
    }
    \caption{Принцип Ферма и поиск точки врезки} \label{fermat}
    \end{center}    
\end{figure}

\section{Дискретная оптимизация}

\section{Учёт ограничений предшествования}

\end{document}